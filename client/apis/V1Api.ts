/* tslint:disable */
/* eslint-disable */
/**
 * Nine Yards REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: rabbitminers@zohomail.eu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Audit,
  AuthenticatedUser,
  EditProject,
  EditSubTask,
  EditTask,
  EditTaskGroup,
  FullTask,
  Login,
  Project,
  ProjectBuilder,
  ProjectMember,
  Register,
  SubTask,
  SubTaskBuilder,
  Task,
  TaskGroup,
  TaskGroupBuilder,
  User,
} from '../models/index';
import {
    AuditFromJSON,
    AuditToJSON,
    AuthenticatedUserFromJSON,
    AuthenticatedUserToJSON,
    EditProjectFromJSON,
    EditProjectToJSON,
    EditSubTaskFromJSON,
    EditSubTaskToJSON,
    EditTaskFromJSON,
    EditTaskToJSON,
    EditTaskGroupFromJSON,
    EditTaskGroupToJSON,
    FullTaskFromJSON,
    FullTaskToJSON,
    LoginFromJSON,
    LoginToJSON,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectBuilderFromJSON,
    ProjectBuilderToJSON,
    ProjectMemberFromJSON,
    ProjectMemberToJSON,
    RegisterFromJSON,
    RegisterToJSON,
    SubTaskFromJSON,
    SubTaskToJSON,
    SubTaskBuilderFromJSON,
    SubTaskBuilderToJSON,
    TaskFromJSON,
    TaskToJSON,
    TaskGroupFromJSON,
    TaskGroupToJSON,
    TaskGroupBuilderFromJSON,
    TaskGroupBuilderToJSON,
    UserFromJSON,
    UserToJSON,
} from '../models/index';

export interface CreateProjectRequest {
    projectBuilder: ProjectBuilder;
}

export interface CreateSubTaskRequest {
    id: string;
    subTaskBuilder: SubTaskBuilder;
}

export interface CreateTaskGroupRequest {
    id: string;
    taskGroupBuilder: Array<TaskGroupBuilder>;
}

export interface EditSubTaskRequest {
    id: string;
    editSubTask: EditSubTask;
}

export interface EditTaskRequest {
    id: string;
    editTask: EditTask;
}

export interface EditTaskGroupRequest {
    id: string;
    editTaskGroup: EditTaskGroup;
}

export interface GetMembersRequest {
    id: string;
}

export interface GetProjectByIdRequest {
    id: string;
}

export interface GetSubTaskByIdRequest {
    id: string;
}

export interface GetSubTasksRequest {
    id: string;
}

export interface GetTaskRequest {
    id: string;
}

export interface GetTaskGroupByIdRequest {
    id: string;
}

export interface GetTaskGroupsRequest {
    id: string;
}

export interface GetTasksRequest {
    id: string;
}

export interface GetUserByIdRequest {
    id: string;
}

export interface InviteMemberRequest {
    id: string;
    requestBody: Array<string>;
}

export interface LoginRequest {
    login: Login;
}

export interface RegisterRequest {
    register: Register;
}

export interface RemoveProjectRequest {
    id: string;
}

export interface RemoveSubTaskRequest {
    id: string;
}

export interface RemoveTaskRequest {
    id: string;
}

export interface RemoveTaskGroupRequest {
    id: string;
}

export interface UpdateProjectRequest {
    id: string;
    editProject: EditProject;
}

/**
 * 
 */
export class V1Api extends runtime.BaseAPI {

    /**
     */
    async createProjectRaw(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.projectBuilder === null || requestParameters.projectBuilder === undefined) {
            throw new runtime.RequiredError('projectBuilder','Required parameter requestParameters.projectBuilder was null or undefined when calling createProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectBuilderToJSON(requestParameters.projectBuilder),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     */
    async createProject(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.createProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new sub task on the given task, with default values except for the name which is provided upon creation. Other values such as the task group and project id are extrapolated and the are therefor not required, any optional fields such as assignments will be empty. The position will default to the last available position in the task group. An audit entry will also be created  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Creates a new sub task on the given task, with default values
     */
    async createSubTaskRaw(requestParameters: CreateSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubTask>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling createSubTask.');
        }

        if (requestParameters.subTaskBuilder === null || requestParameters.subTaskBuilder === undefined) {
            throw new runtime.RequiredError('subTaskBuilder','Required parameter requestParameters.subTaskBuilder was null or undefined when calling createSubTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/tasks/{id}/sub-tasks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubTaskBuilderToJSON(requestParameters.subTaskBuilder),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubTaskFromJSON(jsonValue));
    }

    /**
     * Creates a new sub task on the given task, with default values except for the name which is provided upon creation. Other values such as the task group and project id are extrapolated and the are therefor not required, any optional fields such as assignments will be empty. The position will default to the last available position in the task group. An audit entry will also be created  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Creates a new sub task on the given task, with default values
     */
    async createSubTask(requestParameters: CreateSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubTask> {
        const response = await this.createSubTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createTaskGroupRaw(requestParameters: CreateTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling createTaskGroup.');
        }

        if (requestParameters.taskGroupBuilder === null || requestParameters.taskGroupBuilder === undefined) {
            throw new runtime.RequiredError('taskGroupBuilder','Required parameter requestParameters.taskGroupBuilder was null or undefined when calling createTaskGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/projects/{id}/task-groups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.taskGroupBuilder.map(TaskGroupBuilderToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createTaskGroup(requestParameters: CreateTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createTaskGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Edits the values of a sub task such as it\'s body or weight  If the position of the sub task is updated all other subtasks in a position equal to or greater than the updated position are moved forwards to make space for the new location  This endpoint always requires authentication even if the project is public and for the given member to have permission to edit tasks 
     * Edits the values of a sub task such as it\'s body or weight
     */
    async editSubTaskRaw(requestParameters: EditSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubTask>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editSubTask.');
        }

        if (requestParameters.editSubTask === null || requestParameters.editSubTask === undefined) {
            throw new runtime.RequiredError('editSubTask','Required parameter requestParameters.editSubTask was null or undefined when calling editSubTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/sub-tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditSubTaskToJSON(requestParameters.editSubTask),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubTaskFromJSON(jsonValue));
    }

    /**
     * Edits the values of a sub task such as it\'s body or weight  If the position of the sub task is updated all other subtasks in a position equal to or greater than the updated position are moved forwards to make space for the new location  This endpoint always requires authentication even if the project is public and for the given member to have permission to edit tasks 
     * Edits the values of a sub task such as it\'s body or weight
     */
    async editSubTask(requestParameters: EditSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubTask> {
        const response = await this.editSubTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edits the values of a task such as it\'s name or description, fields like the task\'s id or the parent project\'s id cannot be changed.  All fields are optional, except for when the task group is being updated, in which case the position of the task must also be provided  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Edits the values of a task such as it\'s name or description,
     */
    async editTaskRaw(requestParameters: EditTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editTask.');
        }

        if (requestParameters.editTask === null || requestParameters.editTask === undefined) {
            throw new runtime.RequiredError('editTask','Required parameter requestParameters.editTask was null or undefined when calling editTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditTaskToJSON(requestParameters.editTask),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Edits the values of a task such as it\'s name or description, fields like the task\'s id or the parent project\'s id cannot be changed.  All fields are optional, except for when the task group is being updated, in which case the position of the task must also be provided  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Edits the values of a task such as it\'s name or description,
     */
    async editTask(requestParameters: EditTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Task> {
        const response = await this.editTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async editTaskGroupRaw(requestParameters: EditTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskGroup>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editTaskGroup.');
        }

        if (requestParameters.editTaskGroup === null || requestParameters.editTaskGroup === undefined) {
            throw new runtime.RequiredError('editTaskGroup','Required parameter requestParameters.editTaskGroup was null or undefined when calling editTaskGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/task-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditTaskGroupToJSON(requestParameters.editTaskGroup),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskGroupFromJSON(jsonValue));
    }

    /**
     */
    async editTaskGroup(requestParameters: EditTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskGroup> {
        const response = await this.editTaskGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches information about the user provided by the given bearer token. Despite the password hash being stored in the user struct it is skipped during serialization for security.  This endpoint requires a bearer token to be provided in the request headers. 
     * Fetches information about the user provided by the given
     */
    async getCurrentUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Fetches information about the user provided by the given bearer token. Despite the password hash being stored in the user struct it is skipped during serialization for security.  This endpoint requires a bearer token to be provided in the request headers. 
     * Fetches information about the user provided by the given
     */
    async getCurrentUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.getCurrentUserRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getMembersRaw(requestParameters: GetMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Audit>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/projects/{id}/audits`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
    }

    /**
     */
    async getMembers(requestParameters: GetMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Audit>> {
        const response = await this.getMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the projects and related membership of that the logged in user is a member of. Even if the user has no memberships the request will still return a success response with an empty array in the body.  This endpoint requires a bearer token in order to retreive a given user\'s memberships. 
     * Fetches the projects and related membership of that the logged
     */
    async getMembershipsFromUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProjectMember>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectMemberFromJSON));
    }

    /**
     * Fetches the projects and related membership of that the logged in user is a member of. Even if the user has no memberships the request will still return a success response with an empty array in the body.  This endpoint requires a bearer token in order to retreive a given user\'s memberships. 
     * Fetches the projects and related membership of that the logged
     */
    async getMembershipsFromUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProjectMember>> {
        const response = await this.getMembershipsFromUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * Fetches a project by it\'s id.  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches a project by it\'s id.
     */
    async getProjectByIdRaw(requestParameters: GetProjectByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProjectById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Fetches a project by it\'s id.  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches a project by it\'s id.
     */
    async getProjectById(requestParameters: GetProjectByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.getProjectByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the sub-task specified by the id path parameter  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches the sub-task specified by the id path parameter
     */
    async getSubTaskByIdRaw(requestParameters: GetSubTaskByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubTask>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSubTaskById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/sub-tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubTaskFromJSON(jsonValue));
    }

    /**
     * Fetches the sub-task specified by the id path parameter  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches the sub-task specified by the id path parameter
     */
    async getSubTaskById(requestParameters: GetSubTaskByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubTask> {
        const response = await this.getSubTaskByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches all the sub-tasks on a given task aswell as information about the creators and assignees of the sub-tasks to reduce the need for subsequent requests  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches all the sub-tasks on a given task aswell as information
     */
    async getSubTasksRaw(requestParameters: GetSubTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SubTask>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSubTasks.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/tasks/{id}/sub-tasks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubTaskFromJSON));
    }

    /**
     * Fetches all the sub-tasks on a given task aswell as information about the creators and assignees of the sub-tasks to reduce the need for subsequent requests  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches all the sub-tasks on a given task aswell as information
     */
    async getSubTasks(requestParameters: GetSubTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SubTask>> {
        const response = await this.getSubTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the task specified by the id path parameter aswell as each of its subtasks and information about the creator of the task aswell as it\'s assignees in order to reduce the need for subsequent requests.  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches the task specified by the id path parameter aswell as
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTask>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTaskFromJSON(jsonValue));
    }

    /**
     * Fetches the task specified by the id path parameter aswell as each of its subtasks and information about the creator of the task aswell as it\'s assignees in order to reduce the need for subsequent requests.  If the project is public then this endpoint requires no authentication, if it is private then a membership of the project is required. 
     * Fetches the task specified by the id path parameter aswell as
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTask> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTaskGroupByIdRaw(requestParameters: GetTaskGroupByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskGroup>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTaskGroupById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/task-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskGroupFromJSON(jsonValue));
    }

    /**
     */
    async getTaskGroupById(requestParameters: GetTaskGroupByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskGroup> {
        const response = await this.getTaskGroupByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTaskGroupsRaw(requestParameters: GetTaskGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TaskGroup>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTaskGroups.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/projects/{id}/task-groups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskGroupFromJSON));
    }

    /**
     */
    async getTaskGroups(requestParameters: GetTaskGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TaskGroup>> {
        const response = await this.getTaskGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTasksRaw(requestParameters: GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TaskGroup>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTasks.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/task-groups/{id}/tasks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskGroupFromJSON));
    }

    /**
     */
    async getTasks(requestParameters: GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TaskGroup>> {
        const response = await this.getTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches information about a user given their id. If the user does not exist 403 forbidden will be retured instead of 404 not found for security.  This endpoint may require authentication depending on the privicy level set by the user. 
     * Fetches information about a user given their id. If the user
     */
    async getUserByIdRaw(requestParameters: GetUserByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUserById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Fetches information about a user given their id. If the user does not exist 403 forbidden will be retured instead of 404 not found for security.  This endpoint may require authentication depending on the privicy level set by the user. 
     * Fetches information about a user given their id. If the user
     */
    async getUserById(requestParameters: GetUserByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.getUserByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async inviteMemberRaw(requestParameters: InviteMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling inviteMember.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling inviteMember.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/projects/{id}/members`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async inviteMember(requestParameters: InviteMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.inviteMemberRaw(requestParameters, initOverrides);
    }

    /**
     * Logs in a user given their credentials and returns an authorised bearer token which can be used to authenticate  This token should be placed in subsequent request headers like so  Authorization: Bearer <token> 
     * Logs in a user given their credentials and returns an
     */
    async loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticatedUser>> {
        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling login.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/users/login`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: LoginToJSON(requestParameters.login),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticatedUserFromJSON(jsonValue));
    }

    /**
     * Logs in a user given their credentials and returns an authorised bearer token which can be used to authenticate  This token should be placed in subsequent request headers like so  Authorization: Bearer <token> 
     * Logs in a user given their credentials and returns an
     */
    async login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticatedUser> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Registers a new user and returns their information aswell as an authorised bearer token to prevent the need to login with a subsequent request. 
     * Registers a new user and returns their information aswell as
     */
    async registerRaw(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticatedUser>> {
        if (requestParameters.register === null || requestParameters.register === undefined) {
            throw new runtime.RequiredError('register','Required parameter requestParameters.register was null or undefined when calling register.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/users/register`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterToJSON(requestParameters.register),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticatedUserFromJSON(jsonValue));
    }

    /**
     * Registers a new user and returns their information aswell as an authorised bearer token to prevent the need to login with a subsequent request. 
     * Registers a new user and returns their information aswell as
     */
    async register(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticatedUser> {
        const response = await this.registerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async removeProjectRaw(requestParameters: RemoveProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async removeProject(requestParameters: RemoveProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a given sub task aswell as any references to it such as assignments and notifications  This endpoint always requires authentication even if the project is public and for the given member to have permission to remove tasks 
     * Deletes a given sub task aswell as any references to it such
     */
    async removeSubTaskRaw(requestParameters: RemoveSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeSubTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/sub-tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a given sub task aswell as any references to it such as assignments and notifications  This endpoint always requires authentication even if the project is public and for the given member to have permission to remove tasks 
     * Deletes a given sub task aswell as any references to it such
     */
    async removeSubTask(requestParameters: RemoveSubTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeSubTaskRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a given task aswell as any references to it such as sub-tasks, edges and assignments. This will also create an audit entry  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Deletes a given task aswell as any references to it such as
     */
    async removeTaskRaw(requestParameters: RemoveTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a given task aswell as any references to it such as sub-tasks, edges and assignments. This will also create an audit entry  This endpoint always requires authentication even if the project is public and for the given member to have permission to manage tasks 
     * Deletes a given task aswell as any references to it such as
     */
    async removeTask(requestParameters: RemoveTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeTaskRaw(requestParameters, initOverrides);
    }

    /**
     */
    async removeTaskGroupRaw(requestParameters: RemoveTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskGroup>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeTaskGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/task-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskGroupFromJSON(jsonValue));
    }

    /**
     */
    async removeTaskGroup(requestParameters: RemoveTaskGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskGroup> {
        const response = await this.removeTaskGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateProjectRaw(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProject.');
        }

        if (requestParameters.editProject === null || requestParameters.editProject === undefined) {
            throw new runtime.RequiredError('editProject','Required parameter requestParameters.editProject was null or undefined when calling updateProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditProjectToJSON(requestParameters.editProject),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     */
    async updateProject(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.updateProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
